---

layout:     post
title:      「算法刷题」双指针、滑动窗口的LeetCode题目实现
subtitle:   C++版本
date:       2022-03-02
author:     MRL Liu
header-img: img/the-first.png
catalog: True
tags: [算法刷题]
   
---

[TOC]

​      

## 一、双指针的LeetCode题目

### 1、移动数组中的元素

#### [剑指 Offer 21. 调整数组顺序使奇数位于偶数前面（简单难度）](https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/)

```c++
class Solution {
public:
    /*思路：这道题解决不难，使用额外的数组，只要会判断奇偶数就可以分出两类数，难点在于原地排序算法：双指针的方法：
    左指针寻找偶数值，右指针寻找奇数值，当符合交换条件时，进行两数交换；
    否则指针继续左右运动，寻找符合条件的奇偶值。
    当两指针相遇时，结束循环。*/
    vector<int> exchange(vector<int>& nums) {
        int left=0;//左指针
        int right=nums.size()-1;//右指针
        // 遍历数组[left,right],
        while(left<right){
            // 如果左指针指向偶数，右指针指向奇数，就交换两个数
            if (nums[left] % 2 < nums[right] % 2) {
                swap(nums[left],nums[right]);
            }
            // 如果左指针指向奇数，左指针移动
            if (nums[left] % 2 == 1) left++;
            // 如果右指针指向偶数，右指针移动
            if (nums[right] % 2 == 0) right--;
        }
        return nums;
    }
};
```

## 2、查找排序数组中的2个数

#### [剑指 Offer 57. 和为s的两个数字（简单难度）](https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof/)

#### [剑指 Offer II 006. 排序数组中两个数字之和（简单难度）](https://leetcode-cn.com/problems/kLl5u1/)

```c++
class Solution {
public:
    /*解析：这道题在一个排序数组中查找2个数，使其和为target
    提到排序，可能会选用二分查找法，二分查找法确实可以结合使用
    但是这道题难度简单，用普通的双指针就可以搞定
    排序数组的特点可以作为移动左右指针的依据，和较小右移左指针，和较小左移右指针
    */
    vector<int> twoSum(vector<int>& nums, int target) {
        int left=0;//左指针
        int right=nums.size()-1;//右指针
        int sum=0;
        while(left<=right){
            sum=nums[left]+nums[right];
            // 如果两数和==target，直接返回
            if(sum==target) return {nums[left],nums[right]};
            // 如果两数和>target，说明应该降低两数和，右指针左移即可
            else if(sum>target) right--;
            // 如果两数和<target，说明应该增加两数和，左指针右移即可
            else left++;
        }
        return {nums[left],nums[right]};
    }
};
```



## 二、滑动窗口的LeetCode题目

### 1、连续递增子数组

#### [剑指 Offer 57 - II. 和为s的连续正数序列（简单难度）](https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/)

```c++
class Solution {
public:
    /*解析：本题是从正整数序列中查找所有和为target的连续子序列
    难点在于每个连续子序列的长度、数量是不确定的。
    这种类型题，特别是元素都是正整数，特别适合滑动窗口算法。
    请注意，左指针和右指针的移动时机
    当区间和>=target,右移左指针；当区间和<target，右移右指针
    进阶：求解区间和的数学技巧：(left+right)*(right-left+1)/2
    */
    vector<vector<int>> findContinuousSequence(int target) {
        vector<vector<int>> res;
        int left=1;//正整数序列的第1个数
        int right=2;//正整数序列的第2个数
        int sum=0;
        vector<int> sub;
        // 滑动窗口[left,right]
        while(left<right){
            // 计算滑动窗口[left,right]的和
            sum=0;
            sub.clear();
            for(int i=left;i<=right;i++){
                sum+=i;
                sub.push_back(i);
            }
            // 如果区间和==target，移动左指针
            if(sum==target) {
                res.push_back(sub);
                left++;
            }
            // 如果区间和<target,右指针右移
            else if(sum<target) right++;
            // 如果区间和>target,左指针右移
            else left++;
        }
        return res;
    }
};
```

添加数学公式优化后：

```C++
class Solution {
public:
    vector<vector<int>> findContinuousSequence(int target) {
        vector<vector<int>> res;
        int left=1;//正整数序列的第1个数
        int right=2;//正整数序列的第2个数
        int sum=0;
        vector<int> sub;
        // 滑动窗口[left,right]
        while(left<right){
            // 计算滑动窗口[left,right]的和
            sum=(left+right)*(right-left+1)/2;
            // 如果区间和==target，移动左指针
            if(sum==target) {
                sub.clear();
                for(int i=left;i<=right;i++){
                    sub.push_back(i);
                }
                res.push_back(sub);
                left++;
            }
            // 如果区间和<target,右指针右移
            else if(sum<target) right++;
            // 如果区间和>target,左指针右移
            else left++;
        }
        return res;
    }
};
```

