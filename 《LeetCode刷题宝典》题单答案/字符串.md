---

layout:     post
title:      「算法刷题」字符串
subtitle:   C++版本
date:       2022-03-02
author:     MRL Liu
header-img: img/the-first.png
catalog: True
tags: [算法刷题]
   
---

[TOC]

​      

# 【字符串】

## 【分割字符串】

分割字符串的模板一：额外空间法

优点：字符串开头、中间、结尾存在若干空格都可以处理

缺点：借助了额外的字符空间word

思路：

遍历整个字符串的每个字符：

如果当前字符不为空，添加到word中

如果当前字符为空，判断word是否存在字符，添加进res中，重置word

遍历结束时，判断word是否存在字符，添加进res中

```C++
vector<string> splitWord(string str){
    vector<string> words;
    string word;
    // 遍历字符串
    for(char c:str){
        // 当前字符为空，检查是否添加到结果中
        if(c==' '){
            // 如果word中存在字符，保存到结果中
            if(word.size()) words.push_back(word);
            // 重置word
            word="";
        }
        // 当前字符不为空，添加到word
        else word+=c;
    }
    // 遍历完后word存在字符，添加到结果
    if(word.size()) words.push_back(word);
    return words;
}
```

分割字符串的模板一：原地指针法

优点：字符串开头、中间、结尾存在若干空格都可以处理；不使用额外的空间，原地分割

思路：假设从左到右遍历，：

left从左到右找到第一个非空字符，标记第一个单词的起始位置
right从此时left出发,找到第一个空字符，标记第一个单词的结尾位置
找到[left,right-1],即为第一个单词所在区间

left=right,再次寻找下一个单词

```C++
vector<string> splitWord(string str){
    int left = 0;//左指针
    int right = 0;//右指针
    int len = str.size();
    vector<string> res;
    while (left < len) {
        // left从左到右找到第一个非空字符
        while(left<len&&str[left]==' ') left++;
        if(left>=len) break;//left不可以=len，后续要使用left
        // right从left出发,找到第一个空字符
        right=left;
        while(right<len&&str[right]!=' ') right++;
        // 找到[left,right-1]
        res.push_back(str.substr(left,right-left));
        // 更新right
        left=right;
    }
    return res;
}
```

#### [1816. 截断句子（简单难度）](https://leetcode-cn.com/problems/truncate-sentence/)

```C++
class Solution {
public:
    /*解析：分割+拼接
    最简单的思路是先分割字符串为单词数组，再拼接单词并添加上新的空格，
    该思路的难点是根据空格分割字符串为单词数组。
    */
    string truncateSentence(string s, int k) {
        // 分割字符串为字符串数组
        vector<string> words=splitWord(s);
        // 拼接为一个字符串
        string res;
        for(int i=0;i<k;i++) {
            if(i==0)res+=words[i];
            else{
                res+=" ";
                res+=words[i];
            }
        }
        return res;
    }
    vector<string> splitWord(string str){
        vector<string> words;
        string word;
        // 遍历字符串
        for(char c:str){
            // 当前字符为空，检查是否添加到结果中
            if(c==' '){
                // 如果word中存在字符，保存到结果中
                if(word.size()) words.push_back(word);
                // 重置word
                word="";
            }
            // 当前字符不为空，添加到word
            else word+=c;
        }
        // 遍历完后word存在字符，添加到结果
        if(word.size()) words.push_back(word);
        return words;
    }
};
```

## 【反转字符串】

### 1、反转整个字符串

#### [344. 反转字符串（简单难度）](https://leetcode-cn.com/problems/reverse-string/)

```C++
class Solution {
public:
    /* 本题题意简单，难点在于原地修改字符数组，显然要使用双指针法，首尾交换即可*/
    void reverseString(vector<char>& s) {
        int left=0;// 左指针
        int right=s.size()-1;// 右指针
        // 遍历
        while(left<right){
            swap(s[left++],s[right--]);//交换
        }
    }
};
```

### 2、间隔反转字符串区间

#### [541. 反转字符串 II（简单难度）](https://leetcode-cn.com/problems/reverse-string-ii/)

```c++
class Solution {
public:
    /*本题的题意是反转一小段字符串中的固定长度，每隔 2k 个字符的就将前 k 个字符进行反转
    显然只要实现一个反转指定区间[start,end]的reverse()函数，
    接下来问题就变成了遍历指定区间即可，可以遍历字符串，i每次+2k
    反转时判断[i,i+k)是否存在，不存在则反转[i,len)
    */
    void reverse(string& s, int start, int end) {
        int left = start;// 左指针
        int right = end;//右指针
        while(left < right){
            swap(s[left], s[right]);
            left++;
            right--;
        }
    }
    string reverseStr(string s, int k) {
        // 遍历字符串[0,len),i每次增加2k
        for(int i=0;i<s.size();i+=2*k){
            // [i,i+k)存在，直接反转k个字符
            if (i + k <= s.size()) reverse(s, i, i + k - 1);
            // [i,i+k)不存在，只能反转[i,len),说明剩余字符少于k个，将剩余字符全部反转
            else reverse(s, i, s.size() - 1);
        }
        return s;
    }
};
```

### 3、反转一个句子中的单词

#### [剑指 Offer 58 - I. 翻转单词顺序（简单难度）](https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof/)

#### [151. 翻转字符串里的单词（中等难度）](https://leetcode-cn.com/problems/reverse-words-in-a-string/)

方法一：分割+反转+拼接

```c++
class Solution {
public:
    /*解析：这道题是以空格分隔单词，难点在于开头、中间、结尾的空格数量都不确定。
    方法一：分割+反转+拼接
    最简单的思路是先分割字符串为单词数组，然后反转数组元素，再拼接单词并添加上新的空格，
    该思路的难点是根据空格分割字符串为单词数组。
    */
    string reverseWords(string s) {
        // 分割字符串为字符串数组
        vector<string> words=splitWord(s);
        // 反转字符串数组
        reverse(words.begin(),words.end());
        // 拼接为一个字符串
        string res;
        for(int i=0;i<words.size();i++) {
            if(i==0)res+=words[i];
            else{
                res+=" ";
                res+=words[i];
            }
        }
        return res;
    }
    vector<string> splitWord(string str){
        vector<string> words;
        string word;
        for(char c:str){
            // 遇到空格字符并且word有字符就添加word并且重置word，保证不会添加开头空格
            if(c==' '&&word.size()>0){
                words.push_back(word);
                word="";
            }
            // 不添加空格
            else if(c!=' '){
                word+=c;
            }
        }
        // str末位不一定有空格
        if(word.size()) words.push_back(word);
        return words;
    }
};
```

方法二：原地双指针

```c++
class Solution {
public:
    /*解析：这道题是以空格分隔单词，难点在于开头、中间、结尾的空格数量都不确定。
    方法二：原地双指针（不容易想到）
    因为该方法需要反转，所以从后向前遍历：
    left，right都从最后一个元素出发，right先走到第一个字符处，left=right，走到第一个空格处
    [left+1,right]就是单词所在索引区间，循环重复
    */
    string reverseWords(string s) {
        string res;// 结果字符串
        int n = s.size();
        if(n == 0) return res;
        int left =n-1;// 左指针
        int right = n - 1;// 右指针
        while(right >= 0){
            //从后往前寻找第一字符（如果不是空且没有到头，right就左移）
            while(right >= 0 && s[right] == ' ') right--;
            if(right < 0) break;

            //从后往前寻找第一个空格
            left = right;
            while( left >= 0 && s[left] != ' ' ) left--;

            //添加单词到结果，单词所在位置[left+1,right]
            res += s.substr(left + 1, right - left);
            res += ' ';

            //继续往前分割单词
            right = left;
        }
        //去除最后一个字符空格
        if (!res.empty()) res.pop_back();
        return res;
    }
}
```

#### [186. 翻转字符串里的单词 II（中等难度）](https://leetcode-cn.com/problems/reverse-words-in-a-string-ii/)

```C++
class Solution {
public:
    /* 本题的是反转一个句子中的单词，难点在于必须使用原地算法，即双指针法。
    先对每个单词进行reverse，再对整个字符串reverse，即可得到翻转单词顺序，但是单词中字母顺序不变的效果
    首先实现一个反转字符区间的函数
    然后实现遍历出每个单词，反转每个单词
    遍历后，反转整个字符串即可
    */
    // 反转字符区间
    void reverse(vector<char>& s,int start,int end){
        int left=start;
        int right=end;
        while(left<right){
            swap(s[left++],s[right--]);
        }
    }
    void reverseWords(vector<char>& s) {
        int left = 0;//左指针
        int right = 0;//右指针
        int len = s.size();
        while (left < len) {
            // left从左到右找到第一个非空字符
            while(left<len&&s[left]==' ') left++;
            if(left>=len) break;//left不可以=len，后续要使用left
            // right从left出发,找到第一个空字符
            right=left;
            while(right<len&&s[right]!=' ') right++;
            // 反转[left,right-1]
            reverse(s,left,right-1);
            // 更新right
            left=right;
        }
        reverse(s,0,len-1);
    }
};
```

## 【旋转字符串】

#### [剑指 Offer 58 - II. 左旋转字符串（简单难度）](https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/)

```c++
class Solution {
public:
    /*解析：本题的意思是将字符串的[0,n)移动到字符串的末尾
    方法一：列表遍历拼接（借助额外内存空间）:先拼接[n,s.length())，再拼接[0,n)
    方法二：列表遍历拼接（取余操作简化）
    方法三：3次反转：反转[0,n);反转[n,s.length())；反转[0,s.length())
    */
    string reverseLeftWords(string s, int n) {
        //方法一：列表遍历拼接（借助额外内存空间）
        // string res;
        // // 获取[n,s.length())加入res中
        // for(int i=n;i<s.length();i++){
        //     res+=s[i];
        // }
        // // 获取[0,n)加入res中
        // for(int i=0;i<n;i++){
        //     res+=s[i];
        // }
        // return res;
        //方法二：列表遍历拼接（取余操作简化）
        // string res;
        // int len=s.length();
        // for(int i=n;i<n+len;i++){
        //     res+=s[i%len];
        // }
        // return res;
        //方法三：三次反转
        reverse(s.begin(),s.begin()+n);
        reverse(s.begin()+n,s.end());
        reverse(s.begin(),s.end());
        return s;
    }
};
```

#### [796. 旋转字符串（简单难度）](https://leetcode-cn.com/problems/rotate-string/)

```C++
class Solution {
public:
    /*本题是判断s是否能够通过多次左旋转来得到goal
    我们已经知道左旋转字符串的操作（剑指 Offer 58 - II. 左旋转字符串）
    那么可以通过模拟左旋转来判断，左旋转的次数是有限的：1~s.length()
    */
    bool rotateString(string s, string goal) {
        // 旋转1~s.length()次
        for(int n=1;n<=s.length();n++){
            // 左旋转1个字符
            reverse(s.begin(),s.begin()+1);
            reverse(s.begin()+1,s.end());
            reverse(s.begin(),s.end());
            // 检查本次旋转后是否==goal
            if(s==goal) return true;
        }
        return false;
    }
};
```

## 【匹配字符串】

#### [28. 实现 strStr()（简单难度）](https://leetcode-cn.com/problems/implement-strstr/)

方法一：暴力搜索法

```c++
class Solution {
public:
    /*本题是字符串匹配的经典问题，在文本串txt中查找是否存在模式串ptn
    方法一：暴力搜索：时间复杂度O(mn)，不需要额外空间
    首先遍历文本串txt，让当前字符c和模式串的第一个字符ptn[0]比较，
    如果相等就遍历ptn的其他字符串，看是否继续相等，不相等就退出内层循环。
    */
    int strStr(string txt, string ptn) {
        //如果模式串为空，返回0
        if(ptn=="") return 0;
        //循环遍历txt的每个字符
        for(int i=0;i<txt.size();i++)
        {
            //如果文本串当前字符和模式串第一个字符相等
            if(txt[i]==ptn[0])
            {
                //遍历模式串每个字符
                for(int j=0;j<ptn.size();j++)
                {
                    //如果出现不相等字符，退出内层循环
                    if(txt[i+j]!=ptn[j]) break;
                    //如果遍历完模式串，返回当前初始字符i
                    if(j==ptn.size()-1) return i;
                }
            }
        }
        return -1;
    }
};
```

方法二：KMP算法

```C++
 //获取前缀表(本质上就是一个dp数组)，其只和ptn有关
    int* getNext(string& s) {
        int n=s.size();
        //初始next数组
        int next[n];
        next[0] = 0;//初始装填，next数组第一个一定是0
        int j = 0;//j指向前缀末尾位置，从0开始，前缀的长度，前缀的指示长度
        int i = 1;//i指向后缀末尾位置，从1开始
        //遍历模式串ptn的最长后缀
        for(; i < n; i++) //注意i从1开始
        {
            //如果后缀末尾字符和前缀末尾字符不一样，j回退
            while (j > 0 && s[i] != s[j]) j = next[j-1];
            //如果后缀末尾字符和前缀末尾字符一样，说明找到了相同的前后缀，则前缀++
            if (s[i] == s[j]) j++;
            // 记录此时前后缀的最长长度
            next[i] = j;// 将j（前缀的长度）赋给next[i]
        }
        return next;
    }
int strStr(string txt, string ptn) {
        //如果模式串为空，返回0
        if(ptn=="") return 0;
        //获取前缀表
        int* next=getNext(ptn);
        int j = 0;//负责遍历模式串的字符，和txt字符相同时移动，移动到末尾时说明匹配成功
        //循环遍历文本串每个字符
        for (int i = 0; i < txt.size(); i++) {
            //如果txt当前字符和ptn当前字符不同，借助前缀表回溯模式串当前字符
            while(j > 0 && txt[i] != ptn[j]) j = next[j-1];
            //如果txt当前字符和ptn当前字符相同，ptn当前字符+1
            if (txt[i] == ptn[j]) j++;
            //如果j指向末尾，说明匹配完毕，返回txt的对应初始索引
            if (j == ptn.size() ) return (i - ptn.size() + 1);
        }
        return -1;
    }
```

#### [459. 重复的子字符串（简单难度）](https://leetcode-cn.com/problems/repeated-substring-pattern/)

```C++
class Solution {
public:
    //获取前缀表(本质上就是一个dp数组)，其只和ptn有关
    int* getNext(string& s) {
        int n=s.size();
        //初始next数组
        int next[n];
        next[0] = 0;//初始装填，next数组第一个一定是0
        int j = 0;//j指向前缀末尾位置，从0开始，前缀的长度，前缀的指示长度
        int i = 1;//i指向后缀末尾位置，从1开始
        //遍历模式串ptn的最长后缀
        for(; i < n; i++) //注意i从1开始
        {
            //如果后缀末尾字符和前缀末尾字符不一样，j回退
            while (j > 0 && s[i] != s[j]) j = next[j-1];
            //如果后缀末尾字符和前缀末尾字符一样，说明找到了相同的前后缀，则前缀++
            if (s[i] == s[j]) j++;
            // 记录此时前后缀的最长长度
            next[i] = j;// 将j（前缀的长度）赋给next[i]
        }
        return next;
    }
    bool repeatedSubstringPattern(string s) {
        //获取前缀表
        int* next=getNext(s);
        //如果next[len - 1] != 0则表示存在最长相等前后缀，如果数组长度可以被周期长度整除
        int len = s.size();
        if (next[len - 1] != 0 && len % (len - next[len - 1]) == 0) {
            return true;
        }
        return false;
    }
};
```



## 【字符串比较大小】

#### [剑指 Offer 45. 把数组排成最小的数（中等难度）](https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/)

```c++
class Solution {
public:
    /*解析：本题是一个排序问题，但难点在于如何比较2个数？
    小的数排在前面不一定数就小，例如3和30,330>303.
    解决方案是将整数转成字符串，这样排序a和b两个数时，可以比较a+b和b+a谁更大
    在代码实现时需要知道如何实现自定义排序方式
    */
    // 自定义排序方式
    static bool cmp(string& a,string& b){
        return a + b < b + a;
    }
    string minNumber(vector<int>& nums) {
        // 将整数数组转换为字符串数组
        vector<string> strs;
        for(int num:nums) strs.push_back(to_string(num));
        // 自定义排序
        sort(strs.begin(), strs.end(), cmp);
        // 将字符串数组拼接为字符串
        string res;
        for(string s : strs) res+=s;
        return res;
    }
};
```



#### [剑指 Offer 05. 替换空格（简单难度）](https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/)

方法一：额外空间法

```c++
class Solution {
public:
    /*本题是将字符串中的空格替换成指定的字符串，难点在于指定字符的长度大于1，不能直接替换原有的空格字符
    方法一：额外空间
    新建一个结果字符串，
    遍历原有字符串，
        如果当前字符是空格，就将替换字符串加入结果字符串；
        否则就将当前字符加入结果字符串。
    */
    string replaceSpace(string s) {
        // 方法一：使用额外空间
        string res;
        for(char c:s) {
            if(c == ' ')  res+="%20";
            else res+=c;
        }
        return res;
    }
};
```

方法二：原地指针法

```c++
class Solution {
public:
    /*本题是将字符串中的空格替换成指定的字符串，难点在于指定字符的长度大于1，不能直接替换原有的空格字符
    方法二：原地指针法
    首先扩充字符串的大小
    从后向前遍历字符串，
    快指针:"We are happy."
                        |
    慢指针:"We are happy.      "
                              |
    */
    string replaceSpace(string s) {
        // 方法二：扩充原字符串大小，同时从后向前
        int count = 0; // 统计空格的个数
        int sOldSize = s.size();
        for (int i = 0; i < s.size(); i++) {
            if (s[i] == ' ') {
                count++;
            }
        }
        // 扩充字符串s的大小，也就是每个空格替换成"%20"之后的大小
        s.resize(s.size() + count * 2);
        int sNewSize = s.size();
        // 同时从后向前遍历原有字符串，将空格替换为"%20"
        // [         Oldlen-1,0]
        // [NewLen-1,         0]
        int fast=sOldSize - 1;// 负责遍历原字符串的字符
        int slow=sNewSize - 1;// 负责指向复制字符的位置
        while(fast>=0||slow>=0){
            if (s[fast] != ' ') {
                s[slow] = s[fast];
            } else {
                s[slow] = '0';
                s[slow-1] = '2';
                s[slow-2] = '%';
                slow-=2;
            }
            fast--;
            slow--;
        }
        return s;
    }
};
```

## 
